{"version":3,"sources":["../../src/lib/node.ts"],"names":[],"mappings":";;AAIA,IAAK,IAIJ;AAJD,WAAK,IAAI;IACL,uCAAY,CAAA;IACZ,yCAAa,CAAA;IACb,yCAAa,CAAA;AACjB,CAAC,EAJI,IAAI,KAAJ,IAAI,QAIR;AACD;IAQW,OAAO,CAAC,KAAiB;QAC5B,IAAI,CAAC,OAAO,GAAG,IAAI,GAAG,CAClB,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,KACW,CAAC,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC,CAC7C,CAAC;QACF,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;QACjB,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;QAChB,GAAG,CAAC,CAAC,MAAM,IAAI,IAAI,KAAK,CAAC,CAAC,CAAC;YACvB,MAAM,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YACrC,EAAE,CAAC,CAAC,KAAK,KAAK,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;gBAC1B,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;YACrB,CAAC;QACL,CAAC;QACD,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC;IACvB,CAAC;IAEO,KAAK,CAAC,IAAc;QACxB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACtB,MAAM,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QACzC,MAAM,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;YAChB,KAAK,IAAI,CAAC,SAAS;gBACf,MAAM,CAAC;YAEX,KAAK,IAAI,CAAC,SAAS;gBACf,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,SAAS,CAAC,CAAC;YAEjD,KAAK,IAAI,CAAC,QAAQ,EAAE,CAAC;gBACjB,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;gBACvC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;gBACzC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;gBACvC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACvB,KAAK,CAAC;YACV,CAAC;YAED;gBACI,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;QACzC,CAAC;QACD,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;IACrB,CAAC;;AA7CsB,2BAAS,GAAG,qCAAqC,CAAC;AAD7E,8CA+CC","file":"node.js","sourcesContent":["export interface IDepNode {\r\n    nodes: IDepNode[];\r\n}\r\n\r\nenum Mark {\r\n    Unmarked = 0,\r\n    Temporary = 1,\r\n    Permanent = 2,\r\n}\r\nexport class TopologicalSorter {\r\n    public static readonly NOT_A_DAG = 'Graph is not a Direct acyclic graph';\r\n    public result: IDepNode[];\r\n\r\n    public stack: IDepNode[];\r\n\r\n    private markers: Map<IDepNode, Mark>;\r\n\r\n    public execute(nodes: IDepNode[]): IDepNode[] {\r\n        this.markers = new Map<IDepNode, Mark>(\r\n            nodes.map((n) =>\r\n                <[IDepNode, Mark]> [n, Mark.Unmarked])\r\n        );\r\n        this.result = [];\r\n        this.stack = [];\r\n        for (const node of nodes) {\r\n            const state = this.markers.get(node);\r\n            if (state === Mark.Unmarked) {\r\n                this.visit(node);\r\n            }\r\n        }\r\n        return this.result;\r\n    }\r\n\r\n    private visit(node: IDepNode): void {\r\n        this.stack.push(node);\r\n        const nodeState = this.markers.get(node);\r\n        switch (nodeState) {\r\n            case Mark.Permanent:\r\n                return;\r\n\r\n            case Mark.Temporary:\r\n                throw new Error(TopologicalSorter.NOT_A_DAG);\r\n\r\n            case Mark.Unmarked: {\r\n                this.markers.set(node, Mark.Temporary);\r\n                node.nodes.forEach((n) => this.visit(n));\r\n                this.markers.set(node, Mark.Permanent);\r\n                this.result.push(node);\r\n                break;\r\n            }\r\n\r\n            default:\r\n                throw new Error('invalid state');\r\n        }\r\n        this.stack.pop();\r\n    }\r\n}\r\n"]}